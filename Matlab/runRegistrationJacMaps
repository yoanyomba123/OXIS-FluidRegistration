%% Viscous Fluid Image Registrion
% Author: D Yoan L. Mekontchou Yomba
% Date: 11/16/2018
% Purpose:  
%   The purpose of this script is to implement a fluid registration model
%   in matlab. The Registration model makes use of  the Eularian reference
%   frame and uses the sum of square difference as a cost function.
%% Clear Up Workspace
clc; clear; close all;

%% Add all paths to current workspace recursively

currentFolder = pwd;
addpath(genpath(currentFolder));
%% Load In Images Into Workspace
[Template, Source] = loadImages("Data");

% Source = addLandmark(Source, 1);
Source(140:200, 240:300) = 0;
Source = Source(:,:,1);

Source = imrotate(Source,-60,'bilinear','crop'); % rotate the template image

% display and visualize both images
figure; imagesc([Template, Source]); colormap gray;

% display and visualize difference between both images
figure; imshowpair(Template, Source);


% obtain MSE between images prior to registration
msePreReg = imageMSE(Template, Source);

% Workspace Setup
numpoints = 100;
iter = 500;
mu = 10; lambda = 10;

% tolerance definition
tolerance = struct();
tolerance.deformationTolerance = 50;
tolerance.jacobianTolerance = 0.5;
tolerance.distanceTolerance = 1e-5;

% setup workspace environment
setupWorkSpace(Template, Source, numpoints, iter, mu, lambda, tolerance.deformationTolerance, tolerance.jacobianTolerance, tolerance.distanceTolerance);

% load workspace variables
load("variables.mat");

% plot discretized grid
plot(X,Y,'*r');hold on;grid on
% figure; quiver(X(1:end-2, 1:end-1),Y(1:end-2,1:end-1),Vx,Vy');

%% Start Implementation
i = 1;

% Obtain Initial Interpolated Template
[interpT, U] = performLinearInterpolation(Template,Source,U,gridObject);

% Define The Jacobian Matrix
Jacobian = zeros(length(x), length(y));

numRegrids = 0;

dmin = immse(Template, Source);

while i < iter
    % store prior tolerance value for optimization
    deformationDistTolprevious = tolerance.deformationTolerance;
    
    % perform 2D interpolation
    % turn this into a function
%     wRegrid.x = interpn(yQ{regridCounter}.x,gridObject.grid.x - U.x,'linear');
%     wRegrid.y =  interpn(yQ{regridCounter}.y,gridObject.grid.y - U.y,'linear');
%     wK{i} = wRegrid;
    
    tRegrid.x = X - U.x;
    tRegrid.y = Y - U.y;
    [tK{i}, U] = performLinearInterpolation(Template,tRegrid,U,gridObject);

    % Minimization is performed in the forcefield function
    force = computeForceFieldJacMaps(tK{i}, Source, U, gridObject);
    
    % evaluate the velocity vector fields by solving the linear discretized
    % PDE
    V = computeVelocityVectorFields(stencil, force, gridObject);
    
    
    % compute the pertubation of the displacement field
    [perturbation, delta] = computePertubation(gridObject, U, V, tolerance);    
    
    % compute the jacobian and update u as well as perform regridding if
    % necessary
    regridBool = computeJacobian(gridObject, U, delta, perturbation, tolerance);
    
    if(numRegrids <= tolerance.regridTolerance)
        if(regridBool == "True" && i > 1)
            count = 0;
            while(regridBool == "True")
               numRegrids = numRegrids + 1;
               % lower step size
               Template = deformTemplate(Template, U, gridObject);
               U = clearDisplacement(U);
               tolerance.distanceTolerance = tolerance.distanceTolerance * 2;
               i = i + 1;
               [perturbation, delta] = computePertubation(gridObject, U, V, tolerance); 
               regridBool = computeJacobian(gridObject, U, delta, perturbation, tolerance);
               count = count + 1;
               
               if(numRegrids > tolerance.regridTolerance)
                  break; 
               end
            end
            % deform template
           Template = deformTemplate(Template, U, gridObject);
           
           figure; imagesc(Template);
           
           U = clearDisplacement(U);
        else
            % apply pertubation to displacement field
            if(delta > 0)
               % perturb the displacement field 
               U.x = U.x + (delta .* perturbation.x); 
               U.y = U.y + (delta .* perturbation.y);
            end
            
            % obtain difference between source and template
            diff = immse(deformTemplate(Template, U, gridObject), Source);
%             if(diff < dmin)
%                 % increase the tolerance per iteration
%                 tolerance.distanceTolerance = tolerance.distanceTolerance * 2;
%             else
%                 tolerance.distanceTolerance = tolerance.distanceTolerance/2;
%             end
            
        end
     else
        disp("Max Amount Of Regrids Encountered")
        break;   
    end
    
    i = i + 1;
    if i > iter
       return 
    end
    
end

%% Warp The Image
TemplateOut = 0;
for d = 1: length(U.x)
    for j = 1: length(U.y)
        if(x(d) - U.x(d, j)) <= length(Template) & (y(j) - U.y(d, j)) <= length(Template) & (x(d) -  U.x(d, j)) > 0 & (y(j) - U.y(d, j)) > 0
            TemplateOut(ceil(x(d) -  U.x(d, j)),ceil(y(j) -  U.y(d, j))) =  Source(x(d),y(j)); 
            SourceOut(x(d), y(j)) = Source(x(d), y(j));
        end
    end
end

% plot the outputed image
figure; imagesc([Template, Source]); title("Template vs Source"); colormap gray
figure; imagesc(TemplateOut); colormap gray; title("Transformed Image");
figure; imshowpair(TemplateOut, Source); colormap gray; title("Transformed Image vs Source");
figure; imshowpair(TemplateOut, Template); colormap gray; title("Transformed Template vs Template")

% compute the mse of the deformed template post registration
msePostReg = imageMSE(TemplateOut, Source);

%% Sample Test
% compute image difference between 2 images
imDiff = imageIntensityDiff(TemplateOut, Source);
figure; imagesc(imDiff);